const icalData = $input.item.json.data || '';

const rawLines = icalData.replace(/\r\n/g, '\n').split('\n');
const lines = [];
for (const line of rawLines) {
  if (/^[ \t]/.test(line) && lines.length) {
    lines[lines.length - 1] += line.trimStart();
  } else {
    lines.push(line.trim());
  }
}

const parseDate = (val) => {
  if (!val) return null;
  const m = String(val).match(/(\d{4})(\d{2})(\d{2})/);
  return m ? `${m[1]}-${m[2]}-${m[3]}` : null;
};

const addDays = (iso, n) => {
  const d = new Date(`${iso}T00:00:00Z`);
  d.setUTCDate(d.getUTCDate() + n);
  return d.toISOString().slice(0, 10);
};

const formatDateES = (isoDate) => {
  const [year, month, day] = isoDate.split('-');
  return `${day}/${month}/${year}`;
};

const isNotAvailableSummary = (s) => /NOT\s*AVAILABLE/i.test(String(s || ''));

const events = [];
let inEvent = false;
let start = null;
let end = null;
let summary = '';

for (const line of lines) {
  if (line === 'BEGIN:VEVENT') {
    inEvent = true;
    start = null;
    end = null;
    summary = '';
    continue;
  }

  if (line === 'END:VEVENT') {
    if (inEvent && start) {
      if (!end || end <= start) end = addDays(start, 1);
      const notAvailable = isNotAvailableSummary(summary);
      events.push({
        start,
        end,
        summary: summary || 'BLOCKED',
        blockCheckoutDay: notAvailable,
      });
    }
    inEvent = false;
    continue;
  }

  if (!inEvent) continue;

  if (line.startsWith('DTSTART')) {
    const idx = line.indexOf(':');
    start = idx >= 0 ? parseDate(line.slice(idx + 1)) : null;
  } else if (line.startsWith('DTEND')) {
    const idx = line.indexOf(':');
    end = idx >= 0 ? parseDate(line.slice(idx + 1)) : null;
  } else if (line.startsWith('SUMMARY')) {
    const idx = line.indexOf(':');
    summary = idx >= 0 ? line.slice(idx + 1).trim() : '';
  }
}

events.sort((a, b) => a.start.localeCompare(b.start));

const todayStr = new Date().toISOString().slice(0, 10);
const occupiedDaysSet = new Set();

for (const e of events) {
  let day = e.start;
  while (day < e.end) {
    occupiedDaysSet.add(day);
    day = addDays(day, 1);
  }

  if (e.blockCheckoutDay) {
    occupiedDaysSet.add(e.end);
  }
}

const occupied_days = Array.from(occupiedDaysSet).sort();

const oneYearLater = addDays(todayStr, 365);
const MIN_STAY = 2;

const freeRanges = [];
let currentRangeStart = null;
let consecutiveDays = 0;

let d = todayStr;
while (d < oneYearLater) {
  if (occupiedDaysSet.has(d)) {
    if (currentRangeStart && consecutiveDays > 0) {
      const nights = consecutiveDays - 1;
      if (nights >= MIN_STAY) {
        freeRanges.push({
          start: currentRangeStart,
          end: addDays(currentRangeStart, nights),
          nights: nights
        });
      }
    }
    currentRangeStart = null;
    consecutiveDays = 0;
  } else {
    if (!currentRangeStart) {
      currentRangeStart = d;
      consecutiveDays = 1;
    } else {
      consecutiveDays++;
    }
  }
  d = addDays(d, 1);
}

if (currentRangeStart && consecutiveDays > 0) {
  const nights = consecutiveDays - 1;
  if (nights >= MIN_STAY) {
    freeRanges.push({
      start: currentRangeStart,
      end: addDays(currentRangeStart, nights),
      nights: nights
    });
  }
}

const busy_ranges = [];
for (const day of occupied_days) {
  if (!busy_ranges.length) {
    busy_ranges.push({ from: day, to: day });
    continue;
  }
  const last = busy_ranges[busy_ranges.length - 1];
  const next = addDays(last.to, 1);
  if (day === next) last.to = day;
  else busy_ranges.push({ from: day, to: day });
}

const readable_busy_list = busy_ranges
  .map((r) => r.from === r.to ? `- ${formatDateES(r.from)}` : `- DEL ${formatDateES(r.from)} AL ${formatDateES(r.to)}`)
  .join('\n');

const readable_free_list = freeRanges
  .map((r) => `- DEL ${formatDateES(r.start)} AL ${formatDateES(r.end)} (${r.nights} noches)`)
  .join('\n');

return {
  json: {
    occupied_days,
    busy_ranges,
    readable_busy_list,
    free_ranges: freeRanges,
    readable_free_list,
    min_stay_nights: MIN_STAY,
    total_events: events.length,
    context: {
      today: todayStr,
      year: new Date().getUTCFullYear(),
      month: new Date().toLocaleString('es-ES', { month: 'long', timeZone: 'UTC' })
    }
  }
};