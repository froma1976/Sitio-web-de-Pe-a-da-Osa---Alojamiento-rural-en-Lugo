{
    "name": "AI Concierge - Pena da Osa",
    "nodes": [
        {
            "parameters": {
                "httpMethod": "POST",
                "path": "chat",
                "responseMode": "responseNode",
                "options": {}
            },
            "id": "webhook-node",
            "name": "Webhook",
            "type": "n8n-nodes-base.webhook",
            "typeVersion": 1,
            "position": [
                460,
                300
            ]
        },
        {
            "parameters": {
                "url": "https://ical.avaibook.com/ical/ua_ec96e927592e53c17819712da3d8ebc4-d3d9446802a44259755d38e6d163e820-2b29edfd90f24cdd74d368b5c596ebf1.ics",
                "responseFormat": "string",
                "jsonParameters": true,
                "options": {
                    "responsePropertyName": "data"
                }
            },
            "id": "http-request-node",
            "name": "Get iCal",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 1,
            "position": [
                680,
                300
            ]
        },
        {
            "parameters": {
                "mode": "runOnceForEachItem",
                "jsCode": "const icalData = $input.item.json.data || '';\n\n// Unfold RFC5545 lines\nconst rawLines = icalData.replace(/\\r\\n/g, '\\n').split('\\n');\nconst lines = [];\nfor (const line of rawLines) {\n  if (/^[ \\t]/.test(line) && lines.length) {\n    lines[lines.length - 1] += line.trimStart();\n  } else {\n    lines.push(line.trim());\n  }\n}\n\nconst parseDate = (val) => {\n  if (!val) return null;\n  const m = String(val).match(/(\\d{4})(\\d{2})(\\d{2})/);\n  return m ? `${m[1]}-${m[2]}-${m[3]}` : null;\n};\n\nconst addDays = (iso, n) => {\n  const d = new Date(`${iso}T00:00:00Z`);\n  d.setUTCDate(d.getUTCDate() + n);\n  return d.toISOString().slice(0, 10);\n};\n\nconst formatDateES = (isoDate) => {\n  const [year, month, day] = isoDate.split('-');\n  const months = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];\n  return `${parseInt(day)} de ${months[parseInt(month) - 1]}`;\n};\n\nconst isNotAvailableSummary = (s) => /NOT\\s*AVAILABLE/i.test(String(s || ''));\n\nconst events = [];\nlet inEvent = false;\nlet start = null;\nlet end = null;\nlet summary = '';\n\nfor (const line of lines) {\n  if (line === 'BEGIN:VEVENT') {\n    inEvent = true;\n    start = null;\n    end = null;\n    summary = '';\n    continue;\n  }\n\n  if (line === 'END:VEVENT') {\n    if (inEvent && start) {\n      if (!end || end <= start) end = addDays(start, 1);\n      const notAvailable = isNotAvailableSummary(summary);\n      events.push({\n        start,\n        end,\n        summary: summary || 'BLOCKED',\n        blockCheckoutDay: notAvailable,\n      });\n    }\n    inEvent = false;\n    continue;\n  }\n\n  if (!inEvent) continue;\n\n  if (line.startsWith('DTSTART')) {\n    const idx = line.indexOf(':');\n    start = idx >= 0 ? parseDate(line.slice(idx + 1)) : null;\n  } else if (line.startsWith('DTEND')) {\n    const idx = line.indexOf(':');\n    end = idx >= 0 ? parseDate(line.slice(idx + 1)) : null;\n  } else if (line.startsWith('SUMMARY')) {\n    const idx = line.indexOf(':');\n    summary = idx >= 0 ? line.slice(idx + 1).trim() : '';\n  }\n}\n\nevents.sort((a, b) => a.start.localeCompare(b.start));\n\nconst todayStr = new Date().toISOString().slice(0, 10);\nconst occupiedDaysSet = new Set();\n\nfor (const e of events) {\n  // Bloqueamos el día de entrada, los días de estancia, el día de salida Y EL SIGUIENTE (margen limpieza)\n  let day = e.start;\n  while (day < e.end) {\n    occupiedDaysSet.add(day);\n    day = addDays(day, 1);\n  }\n  // Margen de limpieza: bloqueamos también el día de salida y el siguiente\n  occupiedDaysSet.add(e.end);\n  occupiedDaysSet.add(addDays(e.end, 1));\n}\n\nconst occupied_days = Array.from(occupiedDaysSet).sort();\nconst oneYearLater = addDays(todayStr, 365);\nconst MIN_STAY = 2;\n\nconst freeRanges = [];\nlet currentRangeStart = null;\nlet consecutiveDays = 0;\n\nlet d = todayStr;\nwhile (d < oneYearLater) {\n  if (occupiedDaysSet.has(d)) {\n    if (currentRangeStart && consecutiveDays > 0) {\n      const nights = consecutiveDays - 1;\n      if (nights >= MIN_STAY) {\n        freeRanges.push({\n          start: currentRangeStart,\n          end: addDays(currentRangeStart, nights),\n          nights: nights\n        });\n      }\n    }\n    currentRangeStart = null;\n    consecutiveDays = 0;\n  } else {\n    if (!currentRangeStart) {\n      currentRangeStart = d;\n      consecutiveDays = 1;\n    } else {\n      consecutiveDays++;\n    }\n  }\n  d = addDays(d, 1);\n}\n\nconst readable_free_list = freeRanges.length > 0 \n  ? freeRanges.map((r) => `- Del ${formatDateES(r.start)} al ${formatDateES(r.end)} (${r.nights} noches)`).join('\\\\n')\n  : 'No hay fechas disponibles que cumplan el mínimo de 2 noches y el margen de limpieza en los próximos meses.';\n\nreturn {\n  json: {\n    occupied_days,\n    readable_free_list,\n    min_stay_nights: MIN_STAY,\n    context: {\n      today: todayStr,\n      year: new Date().getUTCFullYear(),\n      month: new Date().toLocaleString('es-ES', { month: 'long', timeZone: 'UTC' })\n    }\n  }\n};\n"
            },
            "id": "code-node",
            "name": "Parse iCal",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                900,
                300
            ]
        },
        {
            "parameters": {
                "resource": "chat",
                "model": "gpt-4o",
                "messages": {
                    "values": [
                        {
                            "role": "system",
                            "content": "Eres Osa, concierge de 'Pena da Osa' (Ribeira Sacra).\n\nINFORMACIÓN TEMPORAL:\n- HOY: {{ $node[\"Parse iCal\"].json[\"context\"][\"today\"] }} (Año: {{ $node[\"Parse iCal\"].json[\"context\"][\"year\"] }})\n- MES ACTUAL: {{ $node[\"Parse iCal\"].json[\"context\"][\"month\"] }}\n\nFUENTE DE VERDAD DE DISPONIBILIDAD (Ya filtrada con 2 noches mínimas y 1 día de margen limpieza):\n{{ $node[\"Parse iCal\"].json[\"readable_free_list\"] }}\n\nREGLAS DE ORO:\n1. MÍNIMO DE ESTANCIA: 2 noches (No aceptes menos bajo ninguna circunstancia).\n2. MARGEN DE LIMPIEZA: El sistema ya ha bloqueado el día de salida y el siguiente. Solo ofrece las fechas que aparecen en 'FUENTE DE VERDAD'.\n3. SI NO HAY disponibilidad en las fechas pedidas, pide disculpas y ofrece las alternativas que veas en la lista.\n\nPROCEDIMIENTO DE RESERVA:\n- Cuando el usuario quiera reservar, pida precios o confirme sus fechas, DEBES proporcionar el enlace de reserva oficial de Avaibook.\n- ENLACE DE RESERVA: https://www.avaibook.com/reservas/nueva_reserva.php?cod_alojamiento=348171&lang=es\n\nACTITUD:\n- Amable, premium y proactiva. Si el usuario te da su nombre, úsalo."
                        },
                        {
                            "role": "user",
                            "content": "={{ (() => { const body = $node[\"Webhook\"].json[\"body\"] || {}; const history = Array.isArray(body.history) ? body.history : []; if (history.length > 0) { return history.map((m) => `${m.role === \"assistant\" ? \"Osa\" : (body.userName || \"Usuario\")}: ${String(m.content || \"\").trim()}`).join(\"\\n\\n\"); } return body.prompt || \"\"; })() }}"
                        }
                    ]
                },
                "options": {}
            },
            "id": "openai-node",
            "name": "OpenAI Chat",
            "type": "n8n-nodes-base.openAi",
            "typeVersion": 1,
            "position": [
                1120,
                300
            ],
            "credentials": {
                "openAiApi": {
                    "id": "OPENAI_CREDENTIAL_ID_PLACEHOLDER",
                    "name": "OpenAI Account"
                }
            }
        },
        {
            "parameters": {
                "respondWith": "json",
                "responseBody": "={{ {\n  \"output\": $json.message.content\n} }}",
                "options": {}
            },
            "id": "respond-node",
            "name": "Respond to Webhook",
            "type": "n8n-nodes-base.respondToWebhook",
            "typeVersion": 1,
            "position": [
                1340,
                300
            ]
        }
    ],
    "connections": {
        "Webhook": {
            "main": [
                [
                    {
                        "node": "Get iCal",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Get iCal": {
            "main": [
                [
                    {
                        "node": "Parse iCal",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Parse iCal": {
            "main": [
                [
                    {
                        "node": "OpenAI Chat",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "OpenAI Chat": {
            "main": [
                [
                    {
                        "node": "Respond to Webhook",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        }
    }
}